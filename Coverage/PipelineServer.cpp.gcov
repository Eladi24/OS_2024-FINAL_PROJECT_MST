        -:    0:Source:PipelineServer.cpp
        -:    0:Graph:PipelineServer.gcno
        -:    0:Data:PipelineServer.gcda
        -:    0:Runs:1
        -:    1:#include <unistd.h>
        -:    2:#include <netinet/in.h>
        -:    3:#include <arpa/inet.h>
        -:    4:#include <sys/socket.h>
        -:    5:#include <sys/types.h>
        -:    6:#include <csignal>
        -:    7:#include <cstring>
        -:    8:#include <csignal>
        -:    9:#include <future>
        -:   10:#include "Graph.hpp"
        -:   11:#include "Tree.hpp"
        -:   12:#include "MSTFactory.hpp"
        -:   13:#include "MSTFactory.hpp"
        -:   14:#include "ActiveObject.hpp"
        -:   15:
        -:   16:const int port = 4050;
        -:   17:function<void(int)> signalHandlerLambda;
        -:   18:atomic<int> clientNumber(0);
        -:   19:mutex graphLock;
        -:   20:mutex futureLock;
        -:   21:mutex &coutLock = ActiveObject::getOutputMutex();
        -:   22:
        -:   23:atomic<bool> terminateFlag(false);
        -:   24:
        -:   25:struct functArgs
        -:   26:{
        -:   27:    int clientSock;
        -:   28:    vector<unique_ptr<ActiveObject>> &pipeline;
        -:   29:    unique_ptr<Graph> &g;
        -:   30:    MSTFactory &factory;
        -:   31:    unique_ptr<Tree> &mst;
        -:   32:};
        -:   33:
function _Z13signalHandleri called 1 returned 0% blocks executed 85%
        1:   34:void signalHandler(int signum)
        -:   35:{
        1:   36:    coutLock.lock();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   37:    cout << "Interrupt signal (" << signum << ") received.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        1:   38:    coutLock.unlock();
call    0 returned 100%
        -:   39:    // Free memory
        1:   40:    terminateFlag.store(true);
call    0 returned 100%
        1:   41:    unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   42:    signalHandlerLambda(signum);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   43:    guard.unlock();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   44:    exit(signum);
call    0 returned 0%
    =====:   45:}
call    0 never executed
        -:   46:
function _Z12sendResponseiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 32 returned 100% blocks executed 46%
       32:   47:void sendResponse(int clientSock, const string &future)
        -:   48:{
       32:   49:    if (send(clientSock, future.c_str(), future.size(), 0) < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:   50:    {
    #####:   51:        unique_lock<mutex> guard(coutLock);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   52:        cerr << "send error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   53:    }
call    0 never executed
call    1 never executed
       32:   54:}
        -:   55:
function _Z9scanGraphRiS_RNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEERSt10unique_ptrI5GraphSt14default_deleteIS8_EE called 4 returned 100% blocks executed 91%
        4:   56:int scanGraph(int &n, int &m, stringstream &ss, unique_ptr<Graph> &g)
        -:   57:{
        -:   58:
        4:   59:    if (!(ss >> n >> m) || n <= 0 || m < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 75% (fallthrough)
branch  6 taken 25%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 25% (fallthrough)
branch 10 taken 75%
        -:   60:    {
        1:   61:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   62:        cerr << "Invalid graph input" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:   63:        return -1;
        1:   64:    }
call    0 returned 100%
call    1 never executed
        -:   65:
        3:   66:    g = make_unique<Graph>(n, m);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   67:
        3:   68:    return 0;
        -:   69:}
        -:   70:
function _Z11scanSrcDestRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEERSt6atomicIiES8_ called 5 returned 100% blocks executed 100%
        5:   71:int scanSrcDest(stringstream &ss, atomic<int> &src, atomic<int> &dest)
        -:   72:{
        -:   73:    int tempSrc, tempDest;
        -:   74:
        5:   75:    if (!(ss >> tempSrc >> tempDest) || tempSrc < 0 || tempDest < 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
branch 11 taken 60% (fallthrough)
branch 12 taken 40%
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
branch 15 taken 40% (fallthrough)
branch 16 taken 60%
        -:   76:    {
        -:   77:
        2:   78:        cerr << "Invalid source or destination" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:   79:        return -1;
        -:   80:    }
        -:   81:
        -:   82:    // Atomically update the atomic<int> variables
        3:   83:    src.store(tempSrc, memory_order_release);
call    0 returned 100%
        3:   84:    dest.store(tempDest, memory_order_release);
call    0 returned 100%
        -:   85:
        3:   86:    return 0;
        -:   87:}
        -:   88:
function _Z14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EE called 3 returned 100% blocks executed 67%
        3:   89:void handleCommands(int clientSock, vector<unique_ptr<ActiveObject>> &pipeline, unique_ptr<Graph> &g, MSTFactory &factory, unique_ptr<Tree> &mst) {
        3:   90:    condition_variable cv;
call    0 returned 100%
        3:   91:    mutex ssLock;
        3:   92:    atomic<bool> done(false);
        3:   93:    char buffer[1024] = {0};
        -:   94:
       31:   95:    while (!terminateFlag.load()) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
       31:   96:        memset(buffer, 0, sizeof(buffer));
       31:   97:        int bytesReceived = recv(clientSock, buffer, sizeof(buffer), 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       31:   98:        if (bytesReceived <= 0) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        2:   99:            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        2:  100:            if (bytesReceived == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  101:                unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  102:                cout << "Connection closed" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:  103:                break;
        2:  104:            } else {
call    0 returned 100%
call    1 never executed
    #####:  105:                cerr << "recv error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  106:            }
        -:  107:        }
       29:  108:        buffer[bytesReceived] = '\0';
       29:  109:        string command(buffer);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      29*:  110:        if (command.empty()) continue;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  111:
       29:  112:        stringstream ss(command);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       29:  113:        string cmd;
call    0 returned 100%
        -:  114:        {
       29:  115:            unique_lock<mutex> sguard(ssLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       29:  116:            ss >> cmd;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       29:  117:        }
call    0 returned 100%
call    1 never executed
        -:  118:
       29:  119:        string future;
call    0 returned 100%
        -:  120:
       29:  121:        if (cmd == "Newgraph") {
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        -:  122:            // Lock the graph mutex to prevent other threads from using the graph
        5:  123:            unique_lock<mutex> graphGuard(graphLock, try_to_lock);
call    0 returned 100%
        -:  124:
        -:  125:            // If the graph resource is being used by another thread, the current thread will not be blocked
        5:  126:            if (!graphGuard.owns_lock()) {
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
        1:  127:                sendResponse(clientSock, "Graph is being used by another thread. Cannot initialize new graph.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  128:                continue;
        -:  129:            }
        4:  130:            if (g != nullptr) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        2:  131:                g.reset();
call    0 returned 100%
        2:  132:                g = nullptr;
call    0 returned 100%
        -:  133:            }
        4:  134:            if (mst != nullptr) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        2:  135:                mst.reset();
call    0 returned 100%
        2:  136:                mst = nullptr;
call    0 returned 100%
        -:  137:            }
        -:  138:
        4:  139:            int n, m, res = 0;
        4:  140:            mutex initLock;
        4:  141:            atomic<bool> initDone(false);
        4:  142:            condition_variable initCV;
call    0 returned 100%
        -:  143:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE_clEv called 4 returned 100% blocks executed 69%
        4:  144:            pipeline[0]->enqueue([&ss, &n, &m, &g, &ssLock, &initLock, &initDone, &initCV, &res]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        4:  145:                unique_lock<mutex> guard2(ssLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  146:                unique_lock<mutex> guard(initLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  147:                res = scanGraph(n, m, ss, g);     
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  148:                initDone.store(true, memory_order_release);
call    0 returned 100%
        4:  149:                initCV.notify_one();
call    0 returned 100%
        4:  150:            });
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        -:  151:
        -:  152:            // Wait for the graph to be created
        -:  153:            {
        4:  154:                unique_lock<mutex> guard(initLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  155:                while (!initDone) {
call    0 returned 100%
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
        4:  156:                    initCV.wait(guard);
call    0 returned 100%
        -:  157:                }
        4:  158:            }
call    0 returned 100%
        4:  159:            if (res == -1) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1:  160:                sendResponse(clientSock, "Invalid graph input. Please enter 2 integers for n and m.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  161:                continue;
        -:  162:            }
        -:  163:
       16:  164:            for (int i = 0; i < m; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       14:  165:                int u = 0, v = 0, w = 0;
        -:  166:
        -:  167:                {
       14:  168:                    unique_lock<mutex> guard(ssLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  169:                    if (!(ss >> u >> v >> w)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
       14:  170:                        ss.clear();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  171:                        ss.str("");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
       14:  172:                        memset(buffer, 0, sizeof(buffer));
       14:  173:                        bytesReceived = recv(clientSock, buffer, sizeof(buffer), 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  174:
       14:  175:                        if (bytesReceived <= 0) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  176:                            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        1:  177:                            if (bytesReceived == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  178:                                unique_lock<mutex> coutGuard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  179:                                cout << "Connection closed by client." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  180:                                break;
        1:  181:                            } else {
call    0 returned 100%
call    1 never executed
    #####:  182:                                cerr << "recv error: " << strerror(errno) << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
    #####:  183:                                break;
        -:  184:                            }
        -:  185:                        }
        -:  186:
       13:  187:                        ss.write(buffer, bytesReceived);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      13*:  188:                        if (!(ss >> u >> v >> w)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
    #####:  189:                            sendResponse(clientSock, "Invalid input format. Please enter 3 integers for u, v, and w.\n");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  190:                            i--; // Retry this iteration since we didn't get valid input
    #####:  191:                            continue;
        -:  192:                        }
        -:  193:                    }
       14:  194:                }
call    0 returned 100%
branch  1 taken 93%
branch  2 taken 7%
branch  3 taken 0%
call    4 never executed
        -:  195:
       13:  196:                if (u < 0 || u > n || v < 0 || v > n || w < 0) {
branch  0 taken 92%
branch  1 taken 8%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 92% (fallthrough)
branch  5 taken 8%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 9% (fallthrough)
branch  9 taken 91%
        3:  197:                    sendResponse(clientSock, "Invalid edge values. Vertices should be in the range [1, n] and weight should be non-negative.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        3:  198:                    i--; // Retry this iteration since the input was invalid
        3:  199:                    continue;
        -:  200:                }
        -:  201:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE0_clEv called 10 returned 100% blocks executed 75%
       10:  202:                pipeline[0]->enqueue([&g, u, v, w]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       10:  203:                    unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:  204:                    g->addEdge(u, v, w);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       10:  205:                });
call    0 returned 100%
call    1 never executed
        -:  206:            }
        -:  207:
        -:  208:            {
        3:  209:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  210:                future = "\nGraph created with " + to_string(n) + " vertices and " + to_string(m) + " edges.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        3:  211:                done.store(true, memory_order_release);
call    0 returned 100%
        3:  212:                cv.notify_one();
call    0 returned 100%
        3:  213:            }
call    0 returned 100%
call    1 never executed
       30:  214:        } else if (cmd == "Prim") {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
call    3 returned 100%
branch  4 taken 60% (fallthrough)
branch  5 taken 40%
call    6 returned 100%
branch  7 taken 12% (fallthrough)
branch  8 taken 88%
call    9 never executed
call   10 never executed
        3:  215:            unique_lock<mutex> graphGuard(graphLock); // Lock for MST operations
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  216:            if (g == nullptr || g->getAdj().empty()) {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 33% (fallthrough)
branch  9 taken 67%
        1:  217:                sendResponse(clientSock, "Graph not initialized\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  218:                continue;
        -:  219:            }
        -:  220:
        2:  221:            if (mst != nullptr) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        1:  222:                mst.reset();
call    0 returned 100%
        1:  223:                mst = nullptr;
call    0 returned 100%
        -:  224:            }
        -:  225:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE1_clEv called 2 returned 100% blocks executed 83%
        2:  226:            pipeline[1]->enqueue([&g, &factory, &mst]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  227:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  228:                factory.setStrategy(new PrimStrategy());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        2:  229:                mst = factory.createMST(g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        2:  230:            });
call    0 returned 100%
call    1 never executed
        -:  231:
        -:  232:            {
        2:  233:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  234:                future = "\nMST created using Prim's algorithm.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  235:            }
call    0 returned 100%
call    1 never executed
        -:  236:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE2_clEv called 2 returned 100% blocks executed 63%
        2:  237:            pipeline[1]->enqueue([&mst, &future, &cv, &done]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  238:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  239:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  240:                future += mst->printMST();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        2:  241:                done.store(true, memory_order_release);
call    0 returned 100%
        2:  242:                cv.notify_one();
call    0 returned 100%
        2:  243:            });
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
       24:  244:        } else if (cmd == "Kruskal") {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
branch  4 taken 14% (fallthrough)
branch  5 taken 86%
call    6 never executed
        3:  245:            unique_lock<mutex> graphGuard(graphLock); // Lock for MST operations
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  246:            if (g == nullptr || g->getAdj().empty()) {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 33% (fallthrough)
branch  9 taken 67%
        1:  247:                sendResponse(clientSock, "Graph not initialized\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  248:                continue;
        -:  249:            }
        -:  250:
        2:  251:            if (mst != nullptr) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        1:  252:                mst.reset();
call    0 returned 100%
        1:  253:                mst = nullptr;
call    0 returned 100%
        -:  254:            }
        -:  255:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE3_clEv called 2 returned 100% blocks executed 83%
        2:  256:            pipeline[2]->enqueue([&g, &factory, &mst]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  257:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  258:                factory.setStrategy(new KruskalStrategy());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        2:  259:                mst = factory.createMST(g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        2:  260:            });
call    0 returned 100%
call    1 never executed
        -:  261:
        -:  262:            {
        2:  263:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  264:                future = "\nMST created using Kruskal's algorithm.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  265:            }
call    0 returned 100%
call    1 never executed
        -:  266:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE4_clEv called 2 returned 100% blocks executed 63%
        2:  267:            pipeline[2]->enqueue([&mst, &future, &cv, &done]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  268:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  269:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  270:                future += mst->printMST();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        2:  271:                done.store(true, memory_order_release);
call    0 returned 100%
        2:  272:                cv.notify_one();
call    0 returned 100%
        2:  273:            });
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
       21:  274:        } else if (cmd == "MSTweight") {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
branch  4 taken 17% (fallthrough)
branch  5 taken 83%
call    6 never executed
        3:  275:            unique_lock<mutex> graphGuard(graphLock); // Lock for MST operations
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  276:            if (mst == nullptr) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1:  277:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  278:                continue;
        -:  279:            }
        -:  280:
        -:  281:            {
        2:  282:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  283:                future = "TOTAL WEIGHT OF THE MST IS: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  284:            }
call    0 returned 100%
call    1 never executed
        -:  285:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE5_clEv called 2 returned 100% blocks executed 60%
        2:  286:            pipeline[3]->enqueue([&mst, &future, &cv, &done]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  287:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  288:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  289:                future += to_string(mst->totalWeight()) + "\n\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
call   15 never executed
call   16 never executed
        2:  290:                done.store(true, memory_order_release);
call    0 returned 100%
        2:  291:                cv.notify_one();
call    0 returned 100%
        2:  292:            });
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
       18:  293:        } else if (cmd == "Shortestpath") {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
branch  4 taken 40% (fallthrough)
branch  5 taken 60%
call    6 never executed
        6:  294:            unique_lock<mutex> graphGuard(graphLock); // Lock for MST operations
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  295:            if (mst == nullptr) {
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        1:  296:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  297:                continue;
        -:  298:            }
        -:  299:
        5:  300:            atomic<int> src{-1}, dest{-1};
        5:  301:            atomic<int> res{0};
        -:  302:
        5:  303:            mutex resMutex;
        5:  304:            condition_variable resCv;
call    0 returned 100%
        5:  305:            bool ready = false;
        -:  306:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE6_clEv called 5 returned 100% blocks executed 100%
        5:  307:            pipeline[4]->enqueue([&ss, &src, &dest, &res, &resMutex, &resCv, &ready]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        5:  308:                res.store(scanSrcDest(ss, src, dest), memory_order_release);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        5:  309:                unique_lock<mutex> lock(resMutex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5:  310:                ready = true;
        5:  311:                resCv.notify_one();
call    0 returned 100%
        5:  312:            });
call    0 returned 100%
        -:  313:
        -:  314:            {
        5:  315:                unique_lock<mutex> lock(resMutex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE7_clEv called 10 returned 100% blocks executed 100%
       15:  316:                resCv.wait(lock, [&ready]() { return ready; });
call    0 returned 100%
        5:  317:            }
call    0 returned 100%
        -:  318:
        5:  319:            if (res.load(memory_order_acquire) == -1) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        2:  320:                sendResponse(clientSock, "Invalid source or destination\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        2:  321:                continue;
        -:  322:            }
        -:  323:
        -:  324:            {
        3:  325:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  326:                future = "SHORTEST PATH FROM " + to_string(src.load()) + " TO " + to_string(dest.load()) + " IS: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        3:  327:            }
call    0 returned 100%
call    1 never executed
        -:  328:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE8_clEv called 3 returned 100% blocks executed 69%
        3:  329:            pipeline[4]->enqueue([&mst, &src, &dest, &future, &cv, &done]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        3:  330:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        9:  331:                string shortestPathResult = mst->shortestPath(src.load(), dest.load());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  332:
        3:  333:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  334:                future += shortestPathResult+ "\n\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        3:  335:                done.store(true, memory_order_release);
call    0 returned 100%
        3:  336:                cv.notify_one();
call    0 returned 100%
        3:  337:            });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 never executed
call    5 never executed
       17:  338:        } else if (cmd == "Longestpath") {
call    0 returned 100%
branch  1 taken 60% (fallthrough)
branch  2 taken 40%
call    3 returned 100%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
call    6 returned 100%
branch  7 taken 33% (fallthrough)
branch  8 taken 67%
call    9 never executed
call   10 never executed
        3:  339:            unique_lock<mutex> graphGuard(graphLock); // Lock for MST operations
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  340:            if (mst == nullptr) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1:  341:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  342:                continue;
        -:  343:            }
        -:  344:
        -:  345:            {
        2:  346:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  347:                future = "THE LONGEST PATH (DIAMETER) OF THE MST IS: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  348:            }
call    0 returned 100%
call    1 never executed
        -:  349:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE9_clEv called 2 returned 100% blocks executed 60%
        2:  350:            pipeline[5]->enqueue([&mst, &future, &cv, &done]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  351:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  352:                int diameter = mst->diameter();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        2:  353:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  354:                future += to_string(diameter) + "\n\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        2:  355:                done.store(true, memory_order_release);
call    0 returned 100%
        2:  356:                cv.notify_one();
call    0 returned 100%
        2:  357:            });
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        9:  358:        } else if (cmd == "Averdist") {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
call    6 never executed
        3:  359:            unique_lock<mutex> graphGuard(graphLock); // Lock for MST operations
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  360:            if (mst == nullptr) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1:  361:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  362:                continue;
        -:  363:            }
        -:  364:
function _ZZ14handleCommandsiRSt6vectorISt10unique_ptrI12ActiveObjectSt14default_deleteIS1_EESaIS4_EERS0_I5GraphS2_IS8_EER10MSTFactoryRS0_I4TreeS2_ISE_EEENKUlvE10_clEv called 2 returned 100% blocks executed 57%
        2:  365:            pipeline[6]->enqueue([&mst, &future, &cv, &done]() {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  366:                unique_lock<mutex> guard(graphLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  367:                unique_lock<mutex> futureGuard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  368:                future += "AVEREGE DISTANCE: " +to_string(mst->averageDistanceEdges()) + "\n\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
        2:  369:                done.store(true, memory_order_release);
call    0 returned 100%
        2:  370:                cv.notify_one();
call    0 returned 100%
        2:  371:            });
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        6:  372:        } else if (cmd == "Exit") {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
call    6 never executed
        1:  373:            sendResponse(clientSock, "Goodbye\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
        1:  374:            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        1:  375:            break;
        -:  376:        } else {
        2:  377:            sendResponse(clientSock, "Invalid command: " + cmd + "\n");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        2:  378:            continue;
        -:  379:        }
        -:  380:
        -:  381:        {
       16:  382:            unique_lock<mutex> guard(futureLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       29:  383:            while (!done) {
call    0 returned 100%
branch  1 taken 45%
branch  2 taken 55% (fallthrough)
       13:  384:                cv.wait(guard);
call    0 returned 100%
        -:  385:            }
       16:  386:            sendResponse(clientSock, future);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       16:  387:            done.store(false, memory_order_release);
call    0 returned 100%
       16:  388:            future.clear();
call    0 returned 100%
       16:  389:        }
call    0 returned 100%
call    1 never executed
       68:  390:    }
call    0 returned 100%
branch  1 taken 55%
branch  2 taken 41%
branch  3 taken 3%
call    4 returned 100%
branch  5 taken 55%
branch  6 taken 41%
branch  7 taken 3%
call    8 returned 100%
branch  9 taken 55%
branch 10 taken 41%
branch 11 taken 3%
call   12 returned 100%
branch 13 taken 55%
branch 14 taken 3%
branch 15 taken 41%
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  391:
        3:  392:    close(clientSock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  393:    // {
        -:  394:    //     unique_lock<mutex> guard(coutLock);
        -:  395:    //     cout << "Thread number " << this_thread::get_id() << " exiting" << endl;
        -:  396:    // }
        3:  397:}
call    0 returned 100%
call    1 never executed
        -:  398:
        -:  399:
function _Z16acceptConnectioni called 4 returned 75% blocks executed 84%
        4:  400:int acceptConnection(int server_sock)
        -:  401:{
        -:  402:    struct sockaddr_in client_addr;
        4:  403:    socklen_t sin_size = sizeof(client_addr);
        4:  404:    int client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &sin_size);
call    0 returned 75%
branch  1 taken 75% (fallthrough)
branch  2 taken 0% (throw)
        3:  405:    if (client_sock == -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  406:    {
    #####:  407:        perror("accept");
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  408:        return -1;
        -:  409:    }
        3:  410:    clientNumber.store(clientNumber.load(memory_order_acquire) + 1, memory_order_release);
call    0 returned 100%
        -:  411:    char s[INET6_ADDRSTRLEN];
        3:  412:    inet_ntop(client_addr.sin_family, &client_addr.sin_addr, s, sizeof s);
call    0 returned 100%
        -:  413:    {
        3:  414:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  415:        cout << "New connection from " << s << " on socket " << client_sock << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        6:  416:        cout << "Currently " << clientNumber.load(memory_order_acquire) << " clients connected" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
        3:  417:    }
call    0 returned 100%
call    1 never executed
        3:  418:    return client_sock;
        -:  419:}
        -:  420:
        -:  421:// Server main function
function main called 1 returned 0% blocks executed 54%
        1:  422:int main()
        -:  423:{
        -:  424:
        1:  425:    signal(SIGINT, signalHandler);
call    0 returned 100%
        1:  426:    vector<thread> threads;
call    0 returned 100%
        1:  427:    vector<unique_ptr<ActiveObject>> pipeline;
call    0 returned 100%
        1:  428:    unique_ptr<Graph> g;
        1:  429:    MSTFactory factory;
        1:  430:    unique_ptr<Tree> mst;
        1:  431:    vector<pthread_t> clientThreads;
call    0 returned 100%
        1:  432:    unique_ptr<functArgs> faPtr;
function _ZZ4mainENKUliE_clEi called 1 returned 100% blocks executed 100%
        1:  433:    signalHandlerLambda = [&](int signum)
        -:  434:    {
        -:  435:        // cout << "Freeing memory" << endl;
        -:  436:        // cout << boolalpha << terminateFlag.load() << endl;
        4:  437:        for (auto &thread : clientThreads)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 75%
branch  6 taken 25% (fallthrough)
        -:  438:        {
        3:  439:            pthread_cancel(thread);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  440:            pthread_join(thread, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  441:        }
        1:  442:        clientThreads.clear();
call    0 returned 100%
        1:  443:        clientThreads.shrink_to_fit();
call    0 returned 100%
        1:  444:        faPtr.reset();
call    0 returned 100%
        1:  445:        factory.destroyStrategy();
call    0 returned 100%
        1:  446:        mst.reset();
call    0 returned 100%
        1:  447:        g.reset();
call    0 returned 100%
        8:  448:        for (auto &obj : pipeline)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 88%
branch  6 taken 12% (fallthrough)
        -:  449:        {
        -:  450:            //cout << "Object: " << &obj << endl;
        7:  451:            obj.reset();
call    0 returned 100%
        -:  452:        }
        1:  453:        pipeline.clear();
call    0 returned 100%
        1:  454:        pipeline.shrink_to_fit();
call    0 returned 100%
        2:  455:    };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  456:    // The server socket
        -:  457:    int serverSock;
        -:  458:    struct sockaddr_in serverAddr;
        -:  459:    // The opt variable is used to set the socket options
        1:  460:    int opt = 1;
        -:  461:
        -:  462:    // If the server socket cannot be created, the program will exit
        1:  463:    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  464:    {
    #####:  465:        cerr << "Socket creation error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  466:        exit(1);
call    0 never executed
        -:  467:    }
        -:  468:
        -:  469:    // If the cannot set the socket to reuse the address, the program will exit
        1:  470:    if (setsockopt(serverSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  471:    {
    #####:  472:        cerr << "Setsockopt error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  473:        exit(1);
call    0 never executed
        -:  474:    }
        -:  475:
        -:  476:    // Set the server address
        1:  477:    serverAddr.sin_family = AF_INET;
        1:  478:    serverAddr.sin_addr.s_addr = INADDR_ANY;
        1:  479:    serverAddr.sin_port = htons(port);
        1:  480:    memset(&(serverAddr.sin_zero), '\0', 8);
        -:  481:
        -:  482:    // If the server cannot bind to the address, the program will exit
        1:  483:    if (bind(serverSock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  484:    {
    #####:  485:        cerr << "Bind error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  486:        exit(1);
call    0 never executed
        -:  487:    }
        -:  488:
        -:  489:    // If the server cannot listen for incoming connections, the program will exit
        1:  490:    if (listen(serverSock, 10) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  491:    {
    #####:  492:        cerr << "Listen error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  493:        exit(1);
call    0 never executed
        -:  494:    }
        -:  495:
        -:  496:    {
        1:  497:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  498:        cout << "MST pipeline server waiting for requests on port " << port << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        1:  499:    }
call    0 returned 100%
call    1 never executed
        -:  500:    // The pipeline of active objects
        8:  501:    for (int i = 0; i < 7; i++)
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
        -:  502:    {
        7:  503:        pipeline.push_back(make_unique<ActiveObject>());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  504:    }
        -:  505:    // Accept connections and handle commands
        -:  506:    while (true)
        -:  507:    {
        4:  508:        int newClientSock = acceptConnection(serverSock);
call    0 returned 75%
branch  1 taken 75% (fallthrough)
branch  2 taken 0% (throw)
       3*:  509:        if (newClientSock == -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  510:        {
    #####:  511:            continue;
        -:  512:        }
        -:  513:        // create pthread for each client
        3:  514:        faPtr = unique_ptr<functArgs>(new functArgs{newClientSock, ref(pipeline), ref(g), ref(factory), ref(mst)});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
        -:  515:        pthread_t tid;
function _ZZ4mainENKUlPvE0_clES_ called 3 returned 100% blocks executed 100%
        3:  516:        auto threadFunc = [](void *arg) -> void *
        -:  517:        {
        3:  518:            functArgs *fa = static_cast<functArgs *>(arg);
        3:  519:            handleCommands(fa->clientSock, fa->pipeline, fa->g, fa->factory, fa->mst);
call    0 returned 100%
        -:  520:
        3:  521:            return nullptr;
        -:  522:        };
        3:  523:        pthread_create(&tid, nullptr, threadFunc, faPtr.get());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        3:  524:        clientThreads.push_back(tid);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  525:    }
        -:  526:    close(serverSock);
        -:  527:
        -:  528:    return 0;
    =====:  529:}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
