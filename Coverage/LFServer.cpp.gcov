        -:    0:Source:LFServer.cpp
        -:    0:Graph:LFServer.gcno
        -:    0:Data:LFServer.gcda
        -:    0:Runs:1
        -:    1:#include <unistd.h>
        -:    2:#include <netinet/in.h>
        -:    3:#include <arpa/inet.h>
        -:    4:#include <sys/socket.h>
        -:    5:#include <sys/types.h>
        -:    6:#include <csignal>
        -:    7:#include <cstring>
        -:    8:#include <thread>
        -:    9:#include "Graph.hpp"
        -:   10:#include "Tree.hpp"
        -:   11:#include "MSTFactory.hpp"
        -:   12:#include "MSTFactory.hpp"
        -:   13:#include "LFThreadPool.hpp"
        -:   14:
        -:   15:const int port = 4050;
        -:   16:function<void(int)> signalHandlerLambda;
        -:   17:atomic<int> clientNumber(0);
        -:   18:mutex graphMutex;
        -:   19:mutex &coutLock = LFThreadPool::getOutputMx();
        -:   20:
function _Z13signalHandleri called 1 returned 0% blocks executed 82%
        1:   21:void signalHandler(int signum)
        -:   22:{
        -:   23:    {
        1:   24:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   25:        cout << "Interrupt signal (" << signum << ") received." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        1:   26:    }
call    0 returned 100%
call    1 never executed
        -:   27:    // Free memory
        1:   28:    signalHandlerLambda(signum);
call    0 returned 100%
        1:   29:    exit(signum);
call    0 returned 0%
        -:   30:}
        -:   31:
function _Z12sendResponseiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 29 returned 100% blocks executed 71%
       29:   32:void sendResponse(int clientSock, const string &response)
        -:   33:{
       29:   34:    if (send(clientSock, response.c_str(), response.size(), 0) < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:   35:    {
    #####:   36:        cerr << "send error" << endl;
call    0 never executed
call    1 never executed
        -:   37:    }
       29:   38:}
        -:   39:
function _Z9scanGraphiRiS_RNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEERSt10unique_ptrI5GraphSt14default_deleteIS8_EE called 4 returned 100% blocks executed 100%
        4:   40:int scanGraph(int clientSock, int &n, int &m, stringstream &ss, unique_ptr<Graph> &g)
        -:   41:{
        4:   42:    if (!(ss >> n >> m) || n <= 0 || m < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 75% (fallthrough)
branch  6 taken 25%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 25% (fallthrough)
branch 10 taken 75%
        -:   43:    {
        1:   44:        cerr << "Invalid graph input" << endl;
call    0 returned 100%
call    1 returned 100%
        1:   45:        return -1;
        -:   46:    }
        -:   47:
        3:   48:    g = make_unique<Graph>(n, m);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        3:   49:    return 0;
        -:   50:}
        -:   51:
function _Z11scanSrcDestRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEERiS6_ called 6 returned 100% blocks executed 100%
        6:   52:int scanSrcDest(stringstream &ss, int &src, int &dest)
        -:   53:{
        6:   54:    if (!(ss >> src >> dest) || src < 0 || dest < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 67% (fallthrough)
branch  6 taken 33%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 33% (fallthrough)
branch 10 taken 67%
        -:   55:    {
        2:   56:        cerr << "Invalid source or destination" << endl;
call    0 returned 100%
call    1 returned 100%
        2:   57:        return -1;
        -:   58:    }
        -:   59:
        4:   60:    return 0;
        -:   61:}
        -:   62:
function _Z14handleCommandsiRSt10unique_ptrI5GraphSt14default_deleteIS0_EER10MSTFactoryRS_I4TreeS1_IS7_EE called 3 returned 100% blocks executed 69%
       35:   63:void handleCommands(int clientSock, unique_ptr<Graph> &g, MSTFactory &factory, unique_ptr<Tree> &mst)
        -:   64:{
        -:   65:
        -:   66:    char buffer[1024];
        -:   67:    int bytesReceived;
        -:   68:    while (true)
        -:   69:    {
       35:   70:        bytesReceived = recv(clientSock, buffer, sizeof(buffer), 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       35:   71:        if (bytesReceived <= 0)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:   72:        {
        2:   73:            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
       2*:   74:            if (bytesReceived == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   75:            {
        -:   76:                {
        2:   77:                    unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:   78:                    cout << "Connection closed by client." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:   79:                }
call    0 returned 100%
call    1 never executed
        2:   80:                break;
        -:   81:            }
        -:   82:            else
        -:   83:            {
    #####:   84:                cerr << "recv error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
      13*:   85:                continue;
        -:   86:            }
        -:   87:        }
       33:   88:        buffer[bytesReceived] = '\0';
       33:   89:        string command(buffer);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      33*:   90:        if (command.empty()) continue;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   91:
       33:   92:        stringstream ss(command);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       33:   93:        string cmd;
call    0 returned 100%
       33:   94:        string response;
call    0 returned 100%
       33:   95:        ss >> cmd;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   96:
       33:   97:        if (cmd == "Newgraph")
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
        -:   98:        {
        5:   99:            unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        5:  100:            if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
        -:  101:            {
        1:  102:                response = "Graph is being used by another thread can't initialize new graph\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  103:                continue;
        -:  104:            }
        -:  105:
        4:  106:            if (g != nullptr)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  107:            {
        2:  108:                g.reset();
call    0 returned 100%
        2:  109:                g = nullptr;
call    0 returned 100%
        -:  110:            }
        4:  111:            if (mst != nullptr)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  112:            {
        2:  113:                mst.reset();
call    0 returned 100%
        2:  114:                mst = nullptr;
call    0 returned 100%
        -:  115:            }
        -:  116:            int n, m;
        4:  117:            int res = scanGraph(clientSock, n, m, ss, g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  118:            if (res == -1)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  119:            {
        1:  120:                sendResponse(clientSock, "Invalid graph input. Please enter 2 integers for n and m.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  121:                continue;
        -:  122:            }
        -:  123:
        -:  124:            // Wait for the graph to be created
       15:  125:            for (int i = 0; i < m; i++)
branch  0 taken 87%
branch  1 taken 13% (fallthrough)
        -:  126:            {
       13:  127:                int u = 0, v = 0, w = 0;
        -:  128:
        -:  129:                // Attempt to read and parse the edge data
       13:  130:                if (!(ss >> u >> v >> w))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        -:  131:                {
        -:  132:                    // Clear the stringstream and read new input from the socket
       13:  133:                    ss.clear();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  134:                    ss.str("");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
       13:  135:                    memset(buffer, 0, sizeof(buffer));
       13:  136:                    bytesReceived = recv(clientSock, buffer, sizeof(buffer), 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  137:
        -:  138:                    // Check if we received valid data
       13:  139:                    if (bytesReceived <= 0)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -:  140:                    {
        -:  141:                        // Decrement the client number as we're losing a client
        1:  142:                        clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        1:  143:                        if (bytesReceived == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  144:                        {
        1:  145:                            unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  146:                            cout << "Connection closed by client." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  147:                            break;
        1:  148:                        }
call    0 returned 100%
call    1 never executed
        -:  149:                        else
        -:  150:                        {
        -:  151:
    #####:  152:                            cerr << "recv error: " << strerror(errno) << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
    #####:  153:                            break;
        -:  154:                        }
        -:  155:                    }
        -:  156:
        -:  157:                    // Load the new input into the stringstream
        -:  158:                    {
       12:  159:                        ss.write(buffer, bytesReceived);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  160:
        -:  161:                        // Attempt to parse again with the new data
      12*:  162:                        if (!(ss >> u >> v >> w))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
        -:  163:                        {
    #####:  164:                            sendResponse(clientSock, "Invalid input format. Please enter 3 integers for u, v, and w.\n");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  165:                            i--; // Retry this iteration since we didn't get valid input
       2*:  166:                            continue;
        -:  167:                        }
        -:  168:                    }
        -:  169:                }
        -:  170:
        -:  171:                // Validate the edge values (u, v, w)
       12:  172:                if (u < 0 || u > n || v < 0 || v > n || w < 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 92% (fallthrough)
branch  5 taken 8%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 9% (fallthrough)
branch  9 taken 91%
        -:  173:                {
        2:  174:                    sendResponse(clientSock, "Invalid edge values. Vertices should be in the range [1, n] and weight should be non-negative.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        2:  175:                    i--; // Retry this iteration since the input was invalid
        2:  176:                    continue;
        -:  177:                }
        -:  178:
       10:  179:                g->addEdge(u, v, w);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  180:            }
        3:  181:            response = "Graph created with " + to_string(n) + " vertices and " + to_string(m) + " edges.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        5:  182:        }
call    0 returned 100%
branch  1 taken 60% (fallthrough)
branch  2 taken 40%
call    3 never executed
        -:  183:
       28:  184:        else if (cmd == "Prim")
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
        -:  185:        {
        4:  186:            unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        4:  187:            if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  188:            {
        1:  189:                response = "Graph is being used by another thread can't search for MST prim.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  190:                sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  191:                continue;
        -:  192:            }
        -:  193:
        3:  194:            if (g == nullptr || g->getAdj().empty())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 33% (fallthrough)
branch  9 taken 67%
        -:  195:            {
        1:  196:                cerr << "Graph not initialized" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  197:
        1:  198:                continue;
        -:  199:            }
        2:  200:            if (mst != nullptr)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  201:            {
        1:  202:                mst.reset();
call    0 returned 100%
        1:  203:                mst = nullptr;
call    0 returned 100%
        -:  204:            }
        -:  205:
        2:  206:            factory.setStrategy(new PrimStrategy());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  207:
        2:  208:            mst = factory.createMST(g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        -:  209:
        2:  210:            response = "MST created using Prim's algorithm.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  211:
        2:  212:            response += mst->printMST();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        4:  213:        }
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 never executed
       24:  214:        else if (cmd == "Kruskal")
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        -:  215:        {
        4:  216:            unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        4:  217:            if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  218:            {
        1:  219:                response = "Graph is being used by another thread can't search for MST Kruskal.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  220:                sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  221:                continue;
        -:  222:            }
        3:  223:            if (g == nullptr || g->getAdj().empty())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 33% (fallthrough)
branch  9 taken 67%
        -:  224:            {
        1:  225:                cerr << "Graph not initialized" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  226:                continue;
        -:  227:            }
        2:  228:            if (mst != nullptr)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  229:            {
        1:  230:                mst.reset();
call    0 returned 100%
        1:  231:                mst = nullptr;
call    0 returned 100%
        -:  232:            }
        -:  233:
        2:  234:            factory.setStrategy(new KruskalStrategy());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  235:
        2:  236:            mst = factory.createMST(g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        -:  237:
        2:  238:            response = "MST created using Kruskal's algorithm.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  239:            response += mst->printMST();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        4:  240:        }
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 never executed
        -:  241:
       20:  242:        else if (cmd == "MSTweight")
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
        -:  243:        {
        3:  244:            unique_lock<mutex> mstGuard(graphMutex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  245:            if (mst == nullptr)
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  246:            {
        1:  247:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  248:                continue;
        -:  249:            }
        2:  250:            response = "Total weight of the MST is: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  251:
        2:  252:            response += to_string(mst->totalWeight()) + "\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
call   15 never executed
call   16 never executed
        3:  253:        }
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 never executed
        -:  254:
       17:  255:        else if (cmd == "Shortestpath")
call    0 returned 100%
branch  1 taken 41% (fallthrough)
branch  2 taken 59%
        -:  256:        {
        7:  257:            unique_lock<mutex> mstGuard(graphMutex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  258:            if (mst == nullptr)
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
        -:  259:            {
        1:  260:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  261:                continue;
        -:  262:            }
        -:  263:
        -:  264:            int src, dest;
        -:  265:            int res;
        6:  266:            res = scanSrcDest(ss, src, dest);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  267:
        6:  268:            if (res == -1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  269:                continue;
        4:  270:            response = "Shortest path from " + to_string(src) + " to " + to_string(dest) + " is: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        4:  271:            response += mst->shortestPath(src, dest);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        7:  272:        }
call    0 returned 100%
branch  1 taken 57% (fallthrough)
branch  2 taken 43%
call    3 never executed
       10:  273:        else if (cmd == "Longestpath")
call    0 returned 100%
branch  1 taken 30% (fallthrough)
branch  2 taken 70%
        -:  274:        {
        3:  275:            unique_lock<mutex> mstGuard(graphMutex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  276:            if (mst == nullptr)
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  277:            {
        1:  278:                cerr << "MST not created" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  279:                continue;
        -:  280:            }
        2:  281:            response = "The longest path (diameter) of the MST is: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  282:
        2:  283:            response += to_string(mst->diameter()) + '\n';
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
call   15 never executed
call   16 never executed
        3:  284:        }
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 never executed
        7:  285:        else if (cmd == "Averdist")
call    0 returned 100%
branch  1 taken 57% (fallthrough)
branch  2 taken 43%
        -:  286:        {
        4:  287:            unique_lock<mutex> mstGuard(graphMutex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  288:            if (mst == nullptr)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  289:            {
        2:  290:                sendResponse(clientSock, "MST not created\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        2:  291:                continue;
        -:  292:            }
        -:  293:
        2:  294:            response = "Average distance of the MST is: ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  295:            response += to_string(mst->averageDistanceEdges()) + "\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
call   15 never executed
call   16 never executed
        4:  296:        }
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 never executed
        3:  297:        else if (cmd == "Exit")
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  298:        {
        1:  299:            sendResponse(clientSock, "Goodbye\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -:  300:            {
        1:  301:                unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  302:                cout << "Client: " << clientSock << " disconnected" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        1:  303:                cout << "Thread: " << this_thread::get_id() << " exiting" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
        1:  304:            }
call    0 returned 100%
call    1 never executed
        1:  305:            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        1:  306:            break;
        -:  307:        }
        -:  308:        else
        -:  309:        {
        2:  310:            response = "Invalid command: " + cmd + "\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
        -:  311:        }
        -:  312:        // Send the response to the client
       19:  313:        sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      107:  314:    }
call    0 returned 100%
branch  1 taken 58%
branch  2 taken 39%
branch  3 taken 3%
call    4 returned 100%
branch  5 taken 58%
branch  6 taken 39%
branch  7 taken 3%
call    8 returned 100%
branch  9 taken 58%
branch 10 taken 39%
branch 11 taken 3%
call   12 returned 100%
branch 13 taken 58%
branch 14 taken 3%
branch 15 taken 39%
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        3:  315:    close(clientSock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  316:}
        -:  317:
function _Z16acceptConnectioniRSt10unique_ptrI5GraphSt14default_deleteIS0_EER10MSTFactoryRS_I4TreeS1_IS7_EERS_I12LFThreadPoolS1_ISB_EE called 3 returned 100% blocks executed 70%
        3:  318:void acceptConnection(int server_sock, unique_ptr<Graph> &g, MSTFactory &factory, unique_ptr<Tree> &mst, unique_ptr<LFThreadPool> &pool)
        -:  319:{
        -:  320:    {
        3:  321:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  322:        cout << "Accepting connection on thread: " << this_thread::get_id() << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
        3:  323:    }
call    0 returned 100%
call    1 never executed
        -:  324:
        -:  325:    struct sockaddr_in client_addr;
        3:  326:    socklen_t sin_size = sizeof(client_addr);
        3:  327:    int client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &sin_size);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  328:    if (client_sock == -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  329:    {
    #####:  330:        perror("accept");
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  331:        return;
        -:  332:    }
        3:  333:    clientNumber.store(clientNumber.load(memory_order_acquire) + 1, memory_order_release);
call    0 returned 100%
        -:  334:    char s[INET6_ADDRSTRLEN];
        3:  335:    inet_ntop(client_addr.sin_family, &client_addr.sin_addr, s, sizeof s);
call    0 returned 100%
        -:  336:    {
        3:  337:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  338:        cout << "New connection from " << s << " on socket " << client_sock << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        3:  339:        cout << "Currently " << clientNumber << " clients connected" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
        3:  340:    }
call    0 returned 100%
call    1 never executed
        -:  341:    // Create new event handler for handling the commands and add it to the reactor
function _ZZ16acceptConnectioniRSt10unique_ptrI5GraphSt14default_deleteIS0_EER10MSTFactoryRS_I4TreeS1_IS7_EERS_I12LFThreadPoolS1_ISB_EEENKUlvE_clEv called 3 returned 100% blocks executed 100%
        3:  342:    function<void()> commandHandler = [client_sock, &g, &factory, &mst]()
        -:  343:    {
        3:  344:        handleCommands(client_sock, g, factory, mst);
call    0 returned 100%
        3:  345:    };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  346:    pool->addFd(client_sock, commandHandler);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -:  347:    {
        3:  348:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  349:        cout << "Client: " << client_sock << " was assigned to thread: " << this_thread::get_id() << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
        3:  350:    }
call    0 returned 100%
call    1 never executed
        3:  351:}
call    0 returned 100%
call    1 never executed
        -:  352:
function main called 1 returned 0% blocks executed 51%
        1:  353:int main()
        -:  354:{
        1:  355:    signal(SIGINT, signalHandler);
call    0 returned 100%
        1:  356:    unique_ptr<Reactor> reactor = make_unique<Reactor>();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  357:    unique_ptr<Graph> g;
        1:  358:    unique_ptr<Tree> t;
        1:  359:    MSTFactory factory;
        1:  360:    unique_ptr<LFThreadPool> pool;
        -:  361:    // The server socket
        -:  362:    int serverSock;
        -:  363:
function _ZZ4mainENKUliE_clEi called 1 returned 100% blocks executed 86%
        1:  364:    signalHandlerLambda = [&](int signum)
        -:  365:    {
        -:  366:        {
        1:  367:            unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  368:            cout << "Freeing memory" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  369:        }
call    0 returned 100%
call    1 never executed
        1:  370:        close(serverSock);
call    0 returned 100%
        1:  371:        reactor.reset();
call    0 returned 100%
        1:  372:        pool.reset();
call    0 returned 100%
        1:  373:        factory.destroyStrategy();
call    0 returned 100%
        1:  374:        g.reset();
call    0 returned 100%
        1:  375:        t.reset();
call    0 returned 100%
        2:  376:    };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  377:
        -:  378:    struct sockaddr_in serverAddr;
        -:  379:    // The opt variable is used to set the socket options
        1:  380:    int opt = 1;
        -:  381:
        -:  382:    // If the server socket cannot be created, the program will exit
        1:  383:    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  384:    {
    #####:  385:        cerr << "Socket creation error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  386:        exit(1);
call    0 never executed
        -:  387:    }
        -:  388:
        -:  389:    // If the cannot set the socket to reuse the address, the program will exit
        1:  390:    if (setsockopt(serverSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  391:    {
    #####:  392:        cerr << "Setsockopt error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  393:        exit(1);
call    0 never executed
        -:  394:    }
        -:  395:
        -:  396:    // Set the server address
        1:  397:    serverAddr.sin_family = AF_INET;
        1:  398:    serverAddr.sin_addr.s_addr = INADDR_ANY;
        1:  399:    serverAddr.sin_port = htons(port);
        1:  400:    memset(&(serverAddr.sin_zero), '\0', 8);
        -:  401:
        -:  402:    // If the server cannot bind to the address, the program will exit
        1:  403:    if (bind(serverSock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  404:    {
    #####:  405:        cerr << "Bind error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  406:        exit(1);
call    0 never executed
        -:  407:    }
        -:  408:
        -:  409:    // If the server cannot listen for incoming connections, the program will exit
        1:  410:    if (listen(serverSock, 10) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  411:    {
    #####:  412:        cerr << "Listen error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  413:        exit(1);
call    0 never executed
        -:  414:    }
        -:  415:
        -:  416:    {
        1:  417:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  418:        cout << "MST LF server waiting for requests on port " << port << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        1:  419:        cout << "Server socket: " << serverSock << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        1:  420:    }
call    0 returned 100%
call    1 never executed
        -:  421:
        -:  422:    // Add the acceptConnection function to the reactor as a lambda function
        1:  423:    pool = make_unique<LFThreadPool>(10, *reactor);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
function _ZZ4mainENKUlvE0_clEv called 3 returned 100% blocks executed 100%
        1:  424:    reactor->addHandle(serverSock, [serverSock, &g, &factory, &t, &pool]()
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        3:  425:                       { acceptConnection(serverSock, g, factory, t, pool); });
call    0 returned 100%
        -:  426:    // Allow the threads in the pool to run without the finishing the server
        -:  427:    {
        1:  428:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  429:        cout << "Server running on thread: " << this_thread::get_id() << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
        1:  430:    }
call    0 returned 100%
call    1 never executed
        -:  431:    while (true)
        -:  432:    {
   224098:  433:        this_thread::sleep_for(chrono::milliseconds(1));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  434:    }
        -:  435:    return 0;
    =====:  436:}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
