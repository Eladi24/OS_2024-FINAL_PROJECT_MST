        -:    0:Source:LFServer.cpp
        -:    0:Graph:LFServer.gcno
        -:    0:Data:LFServer.gcda
        -:    0:Runs:2
        -:    1:#include <unistd.h>
        -:    2:#include <netinet/in.h>
        -:    3:#include <arpa/inet.h>
        -:    4:#include <sys/socket.h>
        -:    5:#include <sys/types.h>
        -:    6:#include <csignal>
        -:    7:#include <cstring>
        -:    8:#include <thread>
        -:    9:#include "Graph.hpp"
        -:   10:#include "Tree.hpp"
        -:   11:#include "MSTFactory.hpp"
        -:   12:#include "LFThreadPool.hpp"
        -:   13:
        -:   14:// Constants
        -:   15:const int port = 4050; ///< Server port number
        -:   16:
        -:   17:// Global variables
        -:   18:function<void(int)> signalHandlerLambda; ///< Lambda function for handling signals
        -:   19:atomic<int> clientNumber(0); ///< Tracks the number of connected clients
        -:   20:mutex graphMutex; ///< Mutex for synchronizing access to the graph
        -:   21:mutex &coutLock = LFThreadPool::getOutputMx(); ///< Mutex for synchronizing console output
        -:   22:
        -:   23:/**
        -:   24: * @brief Signal handler function.
        -:   25: * 
        -:   26: * This function handles interrupt signals (e.g., SIGINT) and performs
        -:   27: * cleanup operations before exiting the program.
        -:   28: * 
        -:   29: * @param signum The signal number.
        -:   30: */
function _Z13signalHandleri called 2 returned 0% blocks executed 82%
        2:   31:void signalHandler(int signum)
        -:   32:{
        -:   33:    {
        2:   34:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:   35:        cout << "Interrupt signal (" << signum << ") received." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        2:   36:    }
call    0 returned 100%
call    1 never executed
        -:   37:    // Free memory and exit
        2:   38:    signalHandlerLambda(signum);
call    0 returned 100%
        2:   39:    exit(signum);
call    0 returned 0%
        -:   40:}
        -:   41:
        -:   42:/**
        -:   43: * @brief Sends a response to the client.
        -:   44: * 
        -:   45: * @param clientSock The client's socket descriptor.
        -:   46: * @param response The response string to be sent.
        -:   47: */
function _Z12sendResponseiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 33 returned 100% blocks executed 71%
       33:   48:void sendResponse(int clientSock, const string &response)
        -:   49:{
       33:   50:    if (send(clientSock, response.c_str(), response.size(), 0) < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:   51:    {
    #####:   52:        cerr << "send error" << endl;
call    0 never executed
call    1 never executed
        -:   53:    }
       33:   54:}
        -:   55:
        -:   56:/**
        -:   57: * @brief Scans the graph input from the client.
        -:   58: * 
        -:   59: * @param clientSock The client's socket descriptor.
        -:   60: * @param n Number of vertices.
        -:   61: * @param m Number of edges.
        -:   62: * @param ss The stringstream containing the client's input.
        -:   63: * @param g Unique pointer to the graph object.
        -:   64: * @return int 0 if successful, -1 otherwise.
        -:   65: */
function _Z9scanGraphiRiS_RNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEERSt10unique_ptrI5GraphSt14default_deleteIS8_EE called 4 returned 100% blocks executed 100%
        4:   66:int scanGraph(int clientSock, int &n, int &m, stringstream &ss, unique_ptr<Graph> &g)
        -:   67:{
        4:   68:    if (!(ss >> n >> m) || n <= 0 || m < 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 75% (fallthrough)
branch  4 taken 25%
branch  5 taken 67% (fallthrough)
branch  6 taken 33%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 50% (fallthrough)
branch 10 taken 50%
        -:   69:    {
        2:   70:        cerr << "Invalid graph input" << endl;
call    0 returned 100%
call    1 returned 100%
        2:   71:        return -1;
        -:   72:    }
        -:   73:
        2:   74:    g = make_unique<Graph>(n, m);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        2:   75:    return 0;
        -:   76:}
        -:   77:
        -:   78:
        -:   79:/**
        -:   80: * @brief Handles commands sent by the client.
        -:   81: * 
        -:   82: * This function processes various commands related to graph operations and MST calculations.
        -:   83: * 
        -:   84: * @param clientSock The client's socket descriptor.
        -:   85: * @param g Unique pointer to the graph object.
        -:   86: * @param factory The MSTFactory object for creating MSTs.
        -:   87: * @param mst Unique pointer to the MST (Tree) object.
        -:   88: */
function _Z14handleCommandsiRSt10unique_ptrI5GraphSt14default_deleteIS0_EER10MSTFactoryRS_I4TreeS1_IS7_EE called 2 returned 100% blocks executed 67%
       31:   89:void handleCommands(int clientSock, unique_ptr<Graph> &g, MSTFactory &factory, unique_ptr<Tree> &mst)
        -:   90:{
        -:   91:    char buffer[1024];
        -:   92:    int bytesReceived;
        -:   93:
        -:   94:    while (true)
        -:   95:    {
       31:   96:        bytesReceived = recv(clientSock, buffer, sizeof(buffer), 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       31:   97:        if (bytesReceived <= 0)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:   98:        {
        1:   99:            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
       1*:  100:            if (bytesReceived == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  101:            {
        -:  102:                {
        1:  103:                    unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  104:                    cout << "Connection closed by client." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  105:                }
call    0 returned 100%
call    1 never executed
        1:  106:                break;
        -:  107:            }
        -:  108:            else
        -:  109:            {
    #####:  110:                cerr << "recv error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
      11*:  111:                continue;
        -:  112:            }
        -:  113:        }
       30:  114:        buffer[bytesReceived] = '\0';
       30:  115:        string command(buffer);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      30*:  116:        if (command.empty()) continue;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  117:
       30:  118:        stringstream ss(command);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       30:  119:        string cmd;
call    0 returned 100%
       30:  120:        string response;
call    0 returned 100%
       30:  121:        ss >> cmd;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  122:
       30:  123:        if (cmd == "Newgraph")
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        -:  124:        {
        5:  125:            unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        5:  126:            if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
        -:  127:            {
        1:  128:                response = "Graph is being used by another thread can't initialize new graph\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  129:                continue;
        -:  130:            }
        -:  131:
        4:  132:            if (g != nullptr)
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  133:            {
        1:  134:                g.reset();
call    0 returned 100%
        1:  135:                g = nullptr;
call    0 returned 100%
        -:  136:            }
        4:  137:            if (mst != nullptr)
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  138:            {
        1:  139:                mst.reset();
call    0 returned 100%
        1:  140:                mst = nullptr;
call    0 returned 100%
        -:  141:            }
        -:  142:            int n, m;
        4:  143:            int res = scanGraph(clientSock, n, m, ss, g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  144:            if (res == -1)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  145:            {
        2:  146:                sendResponse(clientSock, "Invalid graph input. Please enter 2 integers for n and m.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        2:  147:                continue;
        -:  148:            }
        -:  149:
        -:  150:            // Wait for the graph to be created
       14:  151:            for (int i = 0; i < m; i++)
branch  0 taken 93%
branch  1 taken 7% (fallthrough)
        -:  152:            {
       13:  153:                int u = 0, v = 0, w = 0;
        -:  154:
        -:  155:                // Attempt to read and parse the edge data
       13:  156:                if (!(ss >> u >> v >> w))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        -:  157:                {
       13:  158:                    ss.clear();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  159:                    ss.str("");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
       13:  160:                    memset(buffer, 0, sizeof(buffer));
       13:  161:                    bytesReceived = recv(clientSock, buffer, sizeof(buffer), 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  162:
       13:  163:                    if (bytesReceived <= 0)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -:  164:                    {
        1:  165:                        clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        1:  166:                        if (bytesReceived == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  167:                        {
        1:  168:                            unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  169:                            cout << "Connection closed by client." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  170:                            break;
        1:  171:                        }
call    0 returned 100%
call    1 never executed
        -:  172:                        else
        -:  173:                        {
    #####:  174:                            cerr << "recv error: " << strerror(errno) << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
    #####:  175:                            break;
        -:  176:                        }
        -:  177:                    }
        -:  178:
       12:  179:                    ss.write(buffer, bytesReceived);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  180:
       12:  181:                    if (!(ss >> u >> v >> w))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 17% (fallthrough)
branch 13 taken 83%
        -:  182:                    {
        2:  183:                        sendResponse(clientSock, "Invalid input format. Please enter 3 integers for u, v, and w.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        2:  184:                        i--;
        6:  185:                        continue;
        -:  186:                    }
        -:  187:                }
        -:  188:
       10:  189:                if (u < 0 || u > n || v < 0 || v > n || w < 0 || u == v)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 89% (fallthrough)
branch  3 taken 11%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 88% (fallthrough)
branch  9 taken 12%
branch 10 taken 14% (fallthrough)
branch 11 taken 86%
        -:  190:                {
        4:  191:                    sendResponse(clientSock, "Invalid edge values. Vertices should be in the range [1, n] and weight should be non-negative.\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        4:  192:                    i--;
        4:  193:                    continue;
        -:  194:                }
        -:  195:
        6:  196:                g->addEdge(u, v, w);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  197:            }
        2:  198:            response = "Graph created with " + to_string(n) + " vertices and " + to_string(m) + " edges.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        5:  199:        }
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
call    3 never executed
       25:  200:        else if (cmd == "Prim" || cmd == "Kruskal")
call    0 returned 100%
branch  1 taken 84% (fallthrough)
branch  2 taken 16%
call    3 returned 100%
branch  4 taken 19% (fallthrough)
branch  5 taken 81%
branch  6 taken 32% (fallthrough)
branch  7 taken 68%
        -:  201:{
        8:  202:    unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        8:  203:    if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  204:    {
        2:  205:        response = "Graph is being used by another thread can't search for MST using " + cmd + ".\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
        2:  206:        sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  207:        continue;
        -:  208:    }
        -:  209:
        6:  210:    if (g == nullptr || g->getAdj().empty())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 33% (fallthrough)
branch  9 taken 67%
        -:  211:    {
        2:  212:        cerr << "Graph not initialized" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:  213:        continue;
        -:  214:    }
        -:  215:
        4:  216:    if (mst != nullptr)
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
        -:  217:    {
        3:  218:        mst.reset();
call    0 returned 100%
        3:  219:        mst = nullptr;
call    0 returned 100%
        -:  220:    }
        -:  221:
        4:  222:    if (cmd == "Prim")
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  223:    {
        2:  224:        factory.setStrategy(new PrimStrategy());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  225:    }
       2*:  226:    else if (cmd == "Kruskal")
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  227:    {
        2:  228:        factory.setStrategy(new KruskalStrategy());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  229:    }
        -:  230:
        -:  231:    else
        -:  232:    {
    #####:  233:        sendResponse(clientSock, "Invalid command: " + cmd + "\n");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
    #####:  234:        continue;
        -:  235:    }
        -:  236:
        4:  237:    mst = factory.createMST(g);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        4:  238:    response = "MST created using " + cmd + " algorithm.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
        4:  239:    response += mst->printMST();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -:  240:
        -:  241:   // Automatically append results for MSTweight, Longestpath, and Averdist
        4:  242:response += "TOTAL WEIGHT OF THE MST IS: " + to_string(mst->totalWeight()) + "\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
        4:  243:response += "THE LONGEST PATH (DIAMETER) OF THE MST IS: " + to_string(mst->diameter()) + '\n';
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
        4:  244:response += "AVERAGE DISTANCE OF THE MST IS: " + to_string(mst->averageDistanceEdges()) + "\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
        -:  245:// Append the shortest path
        4:  246:response += "SHORTEST PATH IS: " + mst->shortestPath() + "\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 never executed
call   17 never executed
call   18 never executed
        -:  247:
        8:  248:}
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 never executed
       17:  249:    else if (cmd == "AddEdge")
call    0 returned 100%
branch  1 taken 47% (fallthrough)
branch  2 taken 53%
        -:  250:    {
        8:  251:        unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        8:  252:        if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
        -:  253:        {
        1:  254:            response = "Graph is being used by another thread can't add edge.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  255:            sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  256:            continue;
        -:  257:        }
        -:  258:
        7:  259:        if (g == nullptr || g->getAdj().empty())
call    0 returned 100%
branch  1 taken 86% (fallthrough)
branch  2 taken 14%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 14% (fallthrough)
branch  9 taken 86%
        -:  260:        {
        1:  261:            response = "Graph not initialized.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  262:            sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  263:            continue;
        -:  264:        }
        -:  265:
        6:  266:        int u = 0, v = 0, w = 0;
        6:  267:        ss >> u >> v >> w;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        6:  268:        if (u < 0 || u > g->getVerticesNumber() || v < 0 || v > g->getVerticesNumber() || w < 0)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 80% (fallthrough)
branch 11 taken 20%
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
branch 14 taken 33% (fallthrough)
branch 15 taken 67%
        -:  269:        {
        2:  270:            response = "Invalid edge values. Vertices should be in the range [1, n] and weight should be non-negative.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  271:        }
        -:  272:        else
        -:  273:        {
        4:  274:            bool res = g->addEdge(u, v, w);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  275:            
        4:  276:            if (!res)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  277:            {
        3:  278:                response = "Invalid edge. Vertices should range from 1 to " + to_string(g->getVerticesNumber()) + ". or edge already exists.\n";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 never executed
call   16 never executed
        -:  279:            }
        -:  280:            else
        -:  281:            {
        1:  282:                response = "Edge added between " + to_string(u) + " and " + to_string(v) + " with weight " + to_string(w) + "\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
branch 19 taken 100% (fallthrough)
branch 20 taken 0% (throw)
call   21 returned 100%
branch 22 taken 100% (fallthrough)
branch 23 taken 0% (throw)
call   24 returned 100%
branch 25 taken 100% (fallthrough)
branch 26 taken 0% (throw)
call   27 returned 100%
call   28 returned 100%
call   29 returned 100%
call   30 returned 100%
call   31 returned 100%
call   32 returned 100%
call   33 returned 100%
call   34 returned 100%
call   35 returned 100%
call   36 returned 100%
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
        -:  283:            }
        -:  284:        }
        8:  285:    }
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
call    3 never executed
        -:  286:
        9:  287:    else if (cmd == "RemoveEdge")
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
        -:  288:    {
        6:  289:        unique_lock<mutex> guard(graphMutex, try_to_lock);
call    0 returned 100%
        6:  290:        if (!guard.owns_lock())
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        -:  291:        {
        1:  292:            response = "Graph is being used by another thread can't remove edge.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  293:            sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  294:            continue;
        -:  295:        }
        -:  296:
        5:  297:        if (g == nullptr || g->getAdj().empty())
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 20% (fallthrough)
branch  9 taken 80%
        -:  298:        {
        1:  299:            response = "Graph not initialized.\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  300:            sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  301:            continue;
        -:  302:        }
        -:  303:
        4:  304:        int u = 0, v = 0;
        4:  305:        ss >> u >> v;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        4:  306:        if (u < 0 || u > g->getVerticesNumber() || v < 0 || v > g->getVerticesNumber())
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 67% (fallthrough)
branch  5 taken 33%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 50% (fallthrough)
branch 13 taken 50%
        -:  307:        {
        2:  308:            response = "Invalid edge values. Vertices should be in the range [1, n].\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  309:        }
        -:  310:        else
        -:  311:        {
        2:  312:            if (!g->removeEdge(u, v))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
        -:  313:            {
        1:  314:                response = "Edge not found between " + to_string(u) + " and " + to_string(v) + "\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        -:  315:            }
        -:  316:            else
        -:  317:            {
        1:  318:                response = "Edge removed between " + to_string(u) + " and " + to_string(v) + "\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        -:  319:        }   }
        6:  320:    }
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 never executed
        -:  321:
        3:  322:        else if (cmd == "Exit")
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  323:        {
        1:  324:            sendResponse(clientSock, "Goodbye\n");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -:  325:            {
        1:  326:                unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  327:                cout << "Client: " << clientSock << " disconnected" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        1:  328:                cout << "Thread: " << this_thread::get_id() << " exiting" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
        1:  329:            }
call    0 returned 100%
call    1 never executed
        1:  330:            clientNumber.store(clientNumber.load(memory_order_acquire) - 1, memory_order_release);
call    0 returned 100%
        1:  331:            break;
        -:  332:        }
        -:  333:        else
        -:  334:        {
        2:  335:            response = "Invalid command: " + cmd + "\n";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
        -:  336:        }
        -:  337:        // Send the response to the client
       18:  338:        sendResponse(clientSock, response);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       95:  339:    }
call    0 returned 100%
branch  1 taken 60%
branch  2 taken 37%
branch  3 taken 3%
call    4 returned 100%
branch  5 taken 60%
branch  6 taken 37%
branch  7 taken 3%
call    8 returned 100%
branch  9 taken 60%
branch 10 taken 37%
branch 11 taken 3%
call   12 returned 100%
branch 13 taken 60%
branch 14 taken 3%
branch 15 taken 37%
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        2:  340:    close(clientSock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  341:}
        -:  342:
        -:  343:/**
        -:  344: * @brief Accepts incoming connections and assigns them to a thread in the pool.
        -:  345: * 
        -:  346: * This function handles the process of accepting new client connections, creating a
        -:  347: * handler for the connection, and assigning the handler to a thread in the thread pool.
        -:  348: * 
        -:  349: * @param server_sock The server's socket descriptor.
        -:  350: * @param g Unique pointer to the graph object.
        -:  351: * @param factory The MSTFactory object for creating MSTs.
        -:  352: * @param mst Unique pointer to the MST (Tree) object.
        -:  353: * @param pool Unique pointer to the thread pool.
        -:  354: */
function _Z16acceptConnectioniRSt10unique_ptrI5GraphSt14default_deleteIS0_EER10MSTFactoryRS_I4TreeS1_IS7_EERS_I12LFThreadPoolS1_ISB_EE called 2 returned 100% blocks executed 70%
        2:  355:void acceptConnection(int server_sock, unique_ptr<Graph> &g, MSTFactory &factory, unique_ptr<Tree> &mst, unique_ptr<LFThreadPool> &pool)
        -:  356:{
        -:  357:    {
        2:  358:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  359:        cout << "[Server] Accepting connection on thread: " << this_thread::get_id() << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
        2:  360:    }
call    0 returned 100%
call    1 never executed
        -:  361:
        -:  362:    struct sockaddr_in client_addr;
        2:  363:    socklen_t sin_size = sizeof(client_addr);
        2:  364:    int client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &sin_size);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  365:    if (client_sock == -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  366:    {
    #####:  367:        perror("accept");
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  368:        return;
        -:  369:    }
        2:  370:    clientNumber.store(clientNumber.load(memory_order_acquire) + 1, memory_order_release);
call    0 returned 100%
        -:  371:    char s[INET6_ADDRSTRLEN];
        2:  372:    inet_ntop(client_addr.sin_family, &client_addr.sin_addr, s, sizeof s);
call    0 returned 100%
        -:  373:    {
        2:  374:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  375:        cout << "[Server] New connection from " << s << " on socket " << client_sock << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        2:  376:        cout << "[Server] Currently " << clientNumber << " clients connected" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
        2:  377:    }
call    0 returned 100%
call    1 never executed
function _ZZ16acceptConnectioniRSt10unique_ptrI5GraphSt14default_deleteIS0_EER10MSTFactoryRS_I4TreeS1_IS7_EERS_I12LFThreadPoolS1_ISB_EEENKUlvE_clEv called 2 returned 100% blocks executed 100%
        2:  378:    function<void()> commandHandler = [client_sock, &g, &factory, &mst]()
        -:  379:    {
        2:  380:        handleCommands(client_sock, g, factory, mst);
call    0 returned 100%
        2:  381:    };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  382:    pool->addFd(client_sock, commandHandler);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -:  383:    {
        2:  384:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  385:        cout << "[Server] Client: " << client_sock << " was assigned to thread: " << this_thread::get_id() << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
        2:  386:    }
call    0 returned 100%
call    1 never executed
        2:  387:}
call    0 returned 100%
call    1 never executed
        -:  388:
        -:  389:/**
        -:  390: * @brief Main function to start the MST server.
        -:  391: * 
        -:  392: * This function sets up the server, initializes the reactor and thread pool,
        -:  393: * and handles incoming connections.
        -:  394: * 
        -:  395: * @return int Returns 0 on successful execution.
        -:  396: */
function main called 2 returned 0% blocks executed 51%
        2:  397:int main()
        -:  398:{
        2:  399:    signal(SIGINT, signalHandler);
call    0 returned 100%
        2:  400:    unique_ptr<Reactor> reactor = make_unique<Reactor>();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  401:    unique_ptr<Graph> g;
        2:  402:    unique_ptr<Tree> t;
        2:  403:    MSTFactory factory;
        2:  404:    unique_ptr<LFThreadPool> pool;
        -:  405:    int serverSock;
        -:  406:
function _ZZ4mainENKUliE_clEi called 2 returned 100% blocks executed 86%
        2:  407:    signalHandlerLambda = [&](int signum)
        -:  408:    {
        -:  409:        {
        2:  410:            unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  411:            cout << "[Server] Freeing memory" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:  412:        }
call    0 returned 100%
call    1 never executed
        2:  413:        close(serverSock);
call    0 returned 100%
        2:  414:        reactor.reset();
call    0 returned 100%
        2:  415:        pool.reset();
call    0 returned 100%
        2:  416:        factory.destroyStrategy();
call    0 returned 100%
        2:  417:        g.reset();
call    0 returned 100%
        2:  418:        t.reset();
call    0 returned 100%
        4:  419:    };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  420:
        -:  421:    struct sockaddr_in serverAddr;
        2:  422:    int opt = 1;
        -:  423:
        2:  424:    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  425:    {
    #####:  426:        cerr << "[Server] Socket creation error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  427:        exit(1);
call    0 never executed
        -:  428:    }
        -:  429:
        2:  430:    if (setsockopt(serverSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  431:    {
    #####:  432:        cerr << "[Server] Setsockopt error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  433:        exit(1);
call    0 never executed
        -:  434:    }
        -:  435:
        2:  436:    serverAddr.sin_family = AF_INET;
        2:  437:    serverAddr.sin_addr.s_addr = INADDR_ANY;
        2:  438:    serverAddr.sin_port = htons(port);
        2:  439:    memset(&(serverAddr.sin_zero), '\0', 8);
        -:  440:
        2:  441:    if (bind(serverSock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  442:    {
    #####:  443:        cerr << "Bind error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  444:        exit(1);
call    0 never executed
        -:  445:    }
        -:  446:
        2:  447:    if (listen(serverSock, 10) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  448:    {
    #####:  449:        cerr << "Listen error" << endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  450:        exit(1);
call    0 never executed
        -:  451:    }
        -:  452:
        -:  453:    {
        2:  454:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  455:        cout << "[Server] MST LF server waiting for requests on port " << port << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        2:  456:        cout << "[Server] Server socket: " << serverSock << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        2:  457:    }
call    0 returned 100%
call    1 never executed
        -:  458:
        2:  459:    pool = make_unique<LFThreadPool>(10, *reactor);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
function _ZZ4mainENKUlvE0_clEv called 2 returned 100% blocks executed 100%
        2:  460:    reactor->addHandle(serverSock, [serverSock, &g, &factory, &t, &pool]()
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        2:  461:                       { acceptConnection(serverSock, g, factory, t, pool); });
call    0 returned 100%
        -:  462:    {
        2:  463:        unique_lock<mutex> guard(coutLock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  464:        cout << "[Server] Server running on thread: " << this_thread::get_id() << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
        2:  465:    }
call    0 returned 100%
call    1 never executed
        -:  466:    while (true)
        -:  467:    {
   195621:  468:        this_thread::sleep_for(chrono::milliseconds(1));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  469:    }
        -:  470:    return 0;
    =====:  471:}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
